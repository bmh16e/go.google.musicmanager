// Code generated by protoc-gen-go.
// source: upload.proto
// DO NOT EDIT!

package musicmanager

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type ResponseStatus_ResponseCode int32

const (
	ResponseStatus_OK                 ResponseStatus_ResponseCode = 1
	ResponseStatus_ALREADY_EXISTS     ResponseStatus_ResponseCode = 2
	ResponseStatus_SOFT_ERROR         ResponseStatus_ResponseCode = 3
	ResponseStatus_METADATA_TOO_LARGE ResponseStatus_ResponseCode = 4
)

var ResponseStatus_ResponseCode_name = map[int32]string{
	1: "OK",
	2: "ALREADY_EXISTS",
	3: "SOFT_ERROR",
	4: "METADATA_TOO_LARGE",
}
var ResponseStatus_ResponseCode_value = map[string]int32{
	"OK":                 1,
	"ALREADY_EXISTS":     2,
	"SOFT_ERROR":         3,
	"METADATA_TOO_LARGE": 4,
}

func (x ResponseStatus_ResponseCode) Enum() *ResponseStatus_ResponseCode {
	p := new(ResponseStatus_ResponseCode)
	*p = x
	return p
}
func (x ResponseStatus_ResponseCode) String() string {
	return proto.EnumName(ResponseStatus_ResponseCode_name, int32(x))
}
func (x *ResponseStatus_ResponseCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResponseStatus_ResponseCode_value, data, "ResponseStatus_ResponseCode")
	if err != nil {
		return err
	}
	*x = ResponseStatus_ResponseCode(value)
	return nil
}

type UploadOperation_Operation int32

const (
	UploadOperation_OPERATION_CREATE UploadOperation_Operation = 1
	UploadOperation_OPERATION_MODIFY UploadOperation_Operation = 2
	UploadOperation_OPERATION_DELETE UploadOperation_Operation = 3
)

var UploadOperation_Operation_name = map[int32]string{
	1: "OPERATION_CREATE",
	2: "OPERATION_MODIFY",
	3: "OPERATION_DELETE",
}
var UploadOperation_Operation_value = map[string]int32{
	"OPERATION_CREATE": 1,
	"OPERATION_MODIFY": 2,
	"OPERATION_DELETE": 3,
}

func (x UploadOperation_Operation) Enum() *UploadOperation_Operation {
	p := new(UploadOperation_Operation)
	*p = x
	return p
}
func (x UploadOperation_Operation) String() string {
	return proto.EnumName(UploadOperation_Operation_name, int32(x))
}
func (x *UploadOperation_Operation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UploadOperation_Operation_value, data, "UploadOperation_Operation")
	if err != nil {
		return err
	}
	*x = UploadOperation_Operation(value)
	return nil
}

// Possible upload states.
type UpdateUploadStateRequest_UploadState int32

const (
	UpdateUploadStateRequest_START   UpdateUploadStateRequest_UploadState = 1
	UpdateUploadStateRequest_PAUSED  UpdateUploadStateRequest_UploadState = 2
	UpdateUploadStateRequest_STOPPED UpdateUploadStateRequest_UploadState = 3
)

var UpdateUploadStateRequest_UploadState_name = map[int32]string{
	1: "START",
	2: "PAUSED",
	3: "STOPPED",
}
var UpdateUploadStateRequest_UploadState_value = map[string]int32{
	"START":   1,
	"PAUSED":  2,
	"STOPPED": 3,
}

func (x UpdateUploadStateRequest_UploadState) Enum() *UpdateUploadStateRequest_UploadState {
	p := new(UpdateUploadStateRequest_UploadState)
	*p = x
	return p
}
func (x UpdateUploadStateRequest_UploadState) String() string {
	return proto.EnumName(UpdateUploadStateRequest_UploadState_name, int32(x))
}
func (x *UpdateUploadStateRequest_UploadState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateUploadStateRequest_UploadState_value, data, "UpdateUploadStateRequest_UploadState")
	if err != nil {
		return err
	}
	*x = UpdateUploadStateRequest_UploadState(value)
	return nil
}

// Response codes to metadata or track sample uploads.
type TrackSampleResponse_ResponseCode int32

const (
	// Track sample was matched.
	TrackSampleResponse_MATCHED TrackSampleResponse_ResponseCode = 1
	// Metadata or sample was for a new track; please upload.
	TrackSampleResponse_UPLOAD_REQUESTED TrackSampleResponse_ResponseCode = 2
	// Track sample message was corrupt in some way; likely you
	// sent a track sample for a track that was not requested.
	TrackSampleResponse_INVALID_SIGNATURE TrackSampleResponse_ResponseCode = 3
	// A song with this client ID has already been uploaded.
	// The server_track_id field in the response holds its server ID.
	TrackSampleResponse_ALREADY_EXISTS TrackSampleResponse_ResponseCode = 4
	// Miscellaneous error.  One known cause for this is trying to
	// upload a Track with a missing or empty title field.
	TrackSampleResponse_PERMANENT_ERROR TrackSampleResponse_ResponseCode = 6
	// Uploaded track count limit reached.
	TrackSampleResponse_TRACK_COUNT_LIMIT_REACHED TrackSampleResponse_ResponseCode = 7
	// Undocumented codes.
	TrackSampleResponse_TRANSIENT_ERROR             TrackSampleResponse_ResponseCode = 5
	TrackSampleResponse_REJECT_STORE_TRACK          TrackSampleResponse_ResponseCode = 8
	TrackSampleResponse_REJECT_STORE_TRACK_BY_LABEL TrackSampleResponse_ResponseCode = 9
	TrackSampleResponse_REJECT_DRM_TRACK            TrackSampleResponse_ResponseCode = 10
)

var TrackSampleResponse_ResponseCode_name = map[int32]string{
	1:  "MATCHED",
	2:  "UPLOAD_REQUESTED",
	3:  "INVALID_SIGNATURE",
	4:  "ALREADY_EXISTS",
	6:  "PERMANENT_ERROR",
	7:  "TRACK_COUNT_LIMIT_REACHED",
	5:  "TRANSIENT_ERROR",
	8:  "REJECT_STORE_TRACK",
	9:  "REJECT_STORE_TRACK_BY_LABEL",
	10: "REJECT_DRM_TRACK",
}
var TrackSampleResponse_ResponseCode_value = map[string]int32{
	"MATCHED":                     1,
	"UPLOAD_REQUESTED":            2,
	"INVALID_SIGNATURE":           3,
	"ALREADY_EXISTS":              4,
	"PERMANENT_ERROR":             6,
	"TRACK_COUNT_LIMIT_REACHED":   7,
	"TRANSIENT_ERROR":             5,
	"REJECT_STORE_TRACK":          8,
	"REJECT_STORE_TRACK_BY_LABEL": 9,
	"REJECT_DRM_TRACK":            10,
}

func (x TrackSampleResponse_ResponseCode) Enum() *TrackSampleResponse_ResponseCode {
	p := new(TrackSampleResponse_ResponseCode)
	*p = x
	return p
}
func (x TrackSampleResponse_ResponseCode) String() string {
	return proto.EnumName(TrackSampleResponse_ResponseCode_name, int32(x))
}
func (x *TrackSampleResponse_ResponseCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackSampleResponse_ResponseCode_value, data, "TrackSampleResponse_ResponseCode")
	if err != nil {
		return err
	}
	*x = TrackSampleResponse_ResponseCode(value)
	return nil
}

// UploadResponse type codes.
type UploadResponse_ResponseType int32

const (
	UploadResponse_METADATA_RESPONSE                UploadResponse_ResponseType = 1
	UploadResponse_PLAYLIST_RESPONSE                UploadResponse_ResponseType = 2
	UploadResponse_PLAYLIST_ENTRY_RESPONSE          UploadResponse_ResponseType = 3
	UploadResponse_SAMPLE_RESPONSE                  UploadResponse_ResponseType = 4
	UploadResponse_GETJOBS_RESPONSE                 UploadResponse_ResponseType = 5
	UploadResponse_AUTH_RESPONSE                    UploadResponse_ResponseType = 6
	UploadResponse_CLIENT_STATE_RESPONSE            UploadResponse_ResponseType = 7
	UploadResponse_UPDATE_UPLOAD_STATE_RESPONSE     UploadResponse_ResponseType = 8
	UploadResponse_DELETE_UPLOAD_REQUESTED_RESPONSE UploadResponse_ResponseType = 9
)

var UploadResponse_ResponseType_name = map[int32]string{
	1: "METADATA_RESPONSE",
	2: "PLAYLIST_RESPONSE",
	3: "PLAYLIST_ENTRY_RESPONSE",
	4: "SAMPLE_RESPONSE",
	5: "GETJOBS_RESPONSE",
	6: "AUTH_RESPONSE",
	7: "CLIENT_STATE_RESPONSE",
	8: "UPDATE_UPLOAD_STATE_RESPONSE",
	9: "DELETE_UPLOAD_REQUESTED_RESPONSE",
}
var UploadResponse_ResponseType_value = map[string]int32{
	"METADATA_RESPONSE":                1,
	"PLAYLIST_RESPONSE":                2,
	"PLAYLIST_ENTRY_RESPONSE":          3,
	"SAMPLE_RESPONSE":                  4,
	"GETJOBS_RESPONSE":                 5,
	"AUTH_RESPONSE":                    6,
	"CLIENT_STATE_RESPONSE":            7,
	"UPDATE_UPLOAD_STATE_RESPONSE":     8,
	"DELETE_UPLOAD_REQUESTED_RESPONSE": 9,
}

func (x UploadResponse_ResponseType) Enum() *UploadResponse_ResponseType {
	p := new(UploadResponse_ResponseType)
	*p = x
	return p
}
func (x UploadResponse_ResponseType) String() string {
	return proto.EnumName(UploadResponse_ResponseType_name, int32(x))
}
func (x *UploadResponse_ResponseType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UploadResponse_ResponseType_value, data, "UploadResponse_ResponseType")
	if err != nil {
		return err
	}
	*x = UploadResponse_ResponseType(value)
	return nil
}

// Return value of UploadService.UpAuth.
type UploadResponse_AuthStatus int32

const (
	// Authorization succeeded.
	UploadResponse_OK UploadResponse_AuthStatus = 8
	// Account has too many devices authorized.
	UploadResponse_MAX_LIMIT_REACHED UploadResponse_AuthStatus = 9
	// Device is authorized with too many accounts.
	UploadResponse_MAX_PER_MACHINE_USERS_EXCEEDED UploadResponse_AuthStatus = 12
	// Returned when UploadService.UpAuth is called with an invalid
	// OAuth 2.0 token.  (The name is due to the fact that the official
	// Music Manager client used to use non-OAuth authorization.)
	UploadResponse_UPGRADE_MUSIC_MANAGER UploadResponse_AuthStatus = 16
	// Undocumented return values.
	UploadResponse_CLIENT_BOUND_TO_OTHER_ACCOUNT UploadResponse_AuthStatus = 10
	UploadResponse_CLIENT_NOT_AUTHORIZED         UploadResponse_AuthStatus = 11
	UploadResponse_CLIENT_PLEASE_RETRY           UploadResponse_AuthStatus = 13
	UploadResponse_NOT_SUBSCRIBED                UploadResponse_AuthStatus = 14
	UploadResponse_INVALID_REQUEST               UploadResponse_AuthStatus = 15
)

var UploadResponse_AuthStatus_name = map[int32]string{
	8:  "OK",
	9:  "MAX_LIMIT_REACHED",
	12: "MAX_PER_MACHINE_USERS_EXCEEDED",
	16: "UPGRADE_MUSIC_MANAGER",
	10: "CLIENT_BOUND_TO_OTHER_ACCOUNT",
	11: "CLIENT_NOT_AUTHORIZED",
	13: "CLIENT_PLEASE_RETRY",
	14: "NOT_SUBSCRIBED",
	15: "INVALID_REQUEST",
}
var UploadResponse_AuthStatus_value = map[string]int32{
	"OK":                             8,
	"MAX_LIMIT_REACHED":              9,
	"MAX_PER_MACHINE_USERS_EXCEEDED": 12,
	"UPGRADE_MUSIC_MANAGER":          16,
	"CLIENT_BOUND_TO_OTHER_ACCOUNT":  10,
	"CLIENT_NOT_AUTHORIZED":          11,
	"CLIENT_PLEASE_RETRY":            13,
	"NOT_SUBSCRIBED":                 14,
	"INVALID_REQUEST":                15,
}

func (x UploadResponse_AuthStatus) Enum() *UploadResponse_AuthStatus {
	p := new(UploadResponse_AuthStatus)
	*p = x
	return p
}
func (x UploadResponse_AuthStatus) String() string {
	return proto.EnumName(UploadResponse_AuthStatus_name, int32(x))
}
func (x *UploadResponse_AuthStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UploadResponse_AuthStatus_value, data, "UploadResponse_AuthStatus")
	if err != nil {
		return err
	}
	*x = UploadResponse_AuthStatus(value)
	return nil
}

// Possible upload statuses.
type TracksToUpload_TrackStatus int32

const (
	TracksToUpload_FORCE_REUPLOAD   TracksToUpload_TrackStatus = 3
	TracksToUpload_UPLOAD_REQUESTED TracksToUpload_TrackStatus = 4
)

var TracksToUpload_TrackStatus_name = map[int32]string{
	3: "FORCE_REUPLOAD",
	4: "UPLOAD_REQUESTED",
}
var TracksToUpload_TrackStatus_value = map[string]int32{
	"FORCE_REUPLOAD":   3,
	"UPLOAD_REQUESTED": 4,
}

func (x TracksToUpload_TrackStatus) Enum() *TracksToUpload_TrackStatus {
	p := new(TracksToUpload_TrackStatus)
	*p = x
	return p
}
func (x TracksToUpload_TrackStatus) String() string {
	return proto.EnumName(TracksToUpload_TrackStatus_name, int32(x))
}
func (x *TracksToUpload_TrackStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TracksToUpload_TrackStatus_value, data, "TracksToUpload_TrackStatus")
	if err != nil {
		return err
	}
	*x = TracksToUpload_TrackStatus(value)
	return nil
}

type OverrideConfigValue_OverridePriority int32

const (
	OverrideConfigValue_DEFAULT_PRIORITY        OverrideConfigValue_OverridePriority = -1
	OverrideConfigValue_LOWEST_PRIORITY         OverrideConfigValue_OverridePriority = 100
	OverrideConfigValue_LOW_PRIORITY            OverrideConfigValue_OverridePriority = 200
	OverrideConfigValue_MEDIUM_PRIORITY         OverrideConfigValue_OverridePriority = 300
	OverrideConfigValue_HIGH_PRIORITY           OverrideConfigValue_OverridePriority = 400
	OverrideConfigValue_HIGHEST_PRIORITY        OverrideConfigValue_OverridePriority = 500
	OverrideConfigValue_DEFAULT_SERVER_PRIORITY OverrideConfigValue_OverridePriority = 300
	OverrideConfigValue_DEFAULT_CLIENT_PRIORITY OverrideConfigValue_OverridePriority = 400
)

var OverrideConfigValue_OverridePriority_name = map[int32]string{
	-1:  "DEFAULT_PRIORITY",
	100: "LOWEST_PRIORITY",
	200: "LOW_PRIORITY",
	300: "MEDIUM_PRIORITY",
	400: "HIGH_PRIORITY",
	500: "HIGHEST_PRIORITY",
	// Duplicate value: 300: "DEFAULT_SERVER_PRIORITY",
	// Duplicate value: 400: "DEFAULT_CLIENT_PRIORITY",
}
var OverrideConfigValue_OverridePriority_value = map[string]int32{
	"DEFAULT_PRIORITY":        -1,
	"LOWEST_PRIORITY":         100,
	"LOW_PRIORITY":            200,
	"MEDIUM_PRIORITY":         300,
	"HIGH_PRIORITY":           400,
	"HIGHEST_PRIORITY":        500,
	"DEFAULT_SERVER_PRIORITY": 300,
	"DEFAULT_CLIENT_PRIORITY": 400,
}

func (x OverrideConfigValue_OverridePriority) Enum() *OverrideConfigValue_OverridePriority {
	p := new(OverrideConfigValue_OverridePriority)
	*p = x
	return p
}
func (x OverrideConfigValue_OverridePriority) String() string {
	return proto.EnumName(OverrideConfigValue_OverridePriority_name, int32(x))
}
func (x *OverrideConfigValue_OverridePriority) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OverrideConfigValue_OverridePriority_value, data, "OverrideConfigValue_OverridePriority")
	if err != nil {
		return err
	}
	*x = OverrideConfigValue_OverridePriority(value)
	return nil
}

type ResponseStatus struct {
	ResponseCode     *ResponseStatus_ResponseCode `protobuf:"varint,1,req,name=response_code,enum=musicmanager.ResponseStatus_ResponseCode" json:"response_code,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *ResponseStatus) Reset()         { *m = ResponseStatus{} }
func (m *ResponseStatus) String() string { return proto.CompactTextString(m) }
func (*ResponseStatus) ProtoMessage()    {}

func (m *ResponseStatus) GetResponseCode() ResponseStatus_ResponseCode {
	if m != nil && m.ResponseCode != nil {
		return *m.ResponseCode
	}
	return ResponseStatus_OK
}

type UploadOperation struct {
	Operation        *UploadOperation_Operation `protobuf:"varint,1,req,name=operation,enum=musicmanager.UploadOperation_Operation" json:"operation,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *UploadOperation) Reset()         { *m = UploadOperation{} }
func (m *UploadOperation) String() string { return proto.CompactTextString(m) }
func (*UploadOperation) ProtoMessage()    {}

func (m *UploadOperation) GetOperation() UploadOperation_Operation {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return UploadOperation_OPERATION_CREATE
}

// Details for a track sample request.
type ChallengeInfo struct {
	// The client ID of the track.
	ClientTrackId *string `protobuf:"bytes,1,req,name=client_track_id" json:"client_track_id,omitempty"`
	// The position in the track in milliseconds where the sample should
	// start.
	StartMillis *int32 `protobuf:"varint,2,req,name=start_millis" json:"start_millis,omitempty"`
	// The duration of the sample in milliseconds.
	DurationMillis *int32 `protobuf:"varint,3,req,name=duration_millis" json:"duration_millis,omitempty"`
	// Undocumented fields.
	ChallengeUserId    *string `protobuf:"bytes,4,opt,name=challenge_user_id" json:"challenge_user_id,omitempty"`
	ChallengeTimestamp *int64  `protobuf:"varint,5,opt,name=challenge_timestamp" json:"challenge_timestamp,omitempty"`
	ExpectMatch        *bool   `protobuf:"varint,6,opt,name=expect_match" json:"expect_match,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *ChallengeInfo) Reset()         { *m = ChallengeInfo{} }
func (m *ChallengeInfo) String() string { return proto.CompactTextString(m) }
func (*ChallengeInfo) ProtoMessage()    {}

func (m *ChallengeInfo) GetClientTrackId() string {
	if m != nil && m.ClientTrackId != nil {
		return *m.ClientTrackId
	}
	return ""
}

func (m *ChallengeInfo) GetStartMillis() int32 {
	if m != nil && m.StartMillis != nil {
		return *m.StartMillis
	}
	return 0
}

func (m *ChallengeInfo) GetDurationMillis() int32 {
	if m != nil && m.DurationMillis != nil {
		return *m.DurationMillis
	}
	return 0
}

func (m *ChallengeInfo) GetChallengeUserId() string {
	if m != nil && m.ChallengeUserId != nil {
		return *m.ChallengeUserId
	}
	return ""
}

func (m *ChallengeInfo) GetChallengeTimestamp() int64 {
	if m != nil && m.ChallengeTimestamp != nil {
		return *m.ChallengeTimestamp
	}
	return 0
}

func (m *ChallengeInfo) GetExpectMatch() bool {
	if m != nil && m.ExpectMatch != nil {
		return *m.ExpectMatch
	}
	return false
}

// A request for a track sample.  The purpose of the signature is
// unknown; all material of interest lies in the challenge_info field.
type SignedChallengeInfo struct {
	ChallengeInfo    *ChallengeInfo `protobuf:"bytes,1,req,name=challenge_info" json:"challenge_info,omitempty"`
	Signature        []byte         `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *SignedChallengeInfo) Reset()         { *m = SignedChallengeInfo{} }
func (m *SignedChallengeInfo) String() string { return proto.CompactTextString(m) }
func (*SignedChallengeInfo) ProtoMessage()    {}

func (m *SignedChallengeInfo) GetChallengeInfo() *ChallengeInfo {
	if m != nil {
		return m.ChallengeInfo
	}
	return nil
}

func (m *SignedChallengeInfo) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// A track sample.
type TrackSample struct {
	// The metadata for the track of which this is a sample.
	Track *Track `protobuf:"bytes,1,req,name=track" json:"track,omitempty"`
	// The track sample request, returned by UploadService.UploadMetadata,
	// to which this is a response.
	SignedChallengeInfo *SignedChallengeInfo `protobuf:"bytes,2,req,name=signed_challenge_info" json:"signed_challenge_info,omitempty"`
	// The audio data of the sample.  Can be empty if one just wants to
	// skip the matching step.
	Sample []byte `protobuf:"bytes,3,req,name=sample" json:"sample,omitempty"`
	// The format of the sample.  It's unknown if Google's servers
	// actually understand anything other than 128kbps MP3.
	SampleFormat *Track_ContentType `protobuf:"varint,4,opt,name=sample_format,enum=musicmanager.Track_ContentType" json:"sample_format,omitempty"`
	// Album art for the sample.  It's unknown if this can be used to
	// upload album art.
	UserAlbumArt     *ImageUnion `protobuf:"bytes,5,opt,name=user_album_art" json:"user_album_art,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TrackSample) Reset()         { *m = TrackSample{} }
func (m *TrackSample) String() string { return proto.CompactTextString(m) }
func (*TrackSample) ProtoMessage()    {}

func (m *TrackSample) GetTrack() *Track {
	if m != nil {
		return m.Track
	}
	return nil
}

func (m *TrackSample) GetSignedChallengeInfo() *SignedChallengeInfo {
	if m != nil {
		return m.SignedChallengeInfo
	}
	return nil
}

func (m *TrackSample) GetSample() []byte {
	if m != nil {
		return m.Sample
	}
	return nil
}

func (m *TrackSample) GetSampleFormat() Track_ContentType {
	if m != nil && m.SampleFormat != nil {
		return *m.SampleFormat
	}
	return Track_MP3
}

func (m *TrackSample) GetUserAlbumArt() *ImageUnion {
	if m != nil {
		return m.UserAlbumArt
	}
	return nil
}

type UploadPlaylistRequest struct {
	UploadOperation  *UploadOperation `protobuf:"bytes,1,req,name=upload_operation" json:"upload_operation,omitempty"`
	Playlist         []*Playlist      `protobuf:"bytes,2,rep,name=playlist" json:"playlist,omitempty"`
	UploaderId       *string          `protobuf:"bytes,3,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *UploadPlaylistRequest) Reset()         { *m = UploadPlaylistRequest{} }
func (m *UploadPlaylistRequest) String() string { return proto.CompactTextString(m) }
func (*UploadPlaylistRequest) ProtoMessage()    {}

func (m *UploadPlaylistRequest) GetUploadOperation() *UploadOperation {
	if m != nil {
		return m.UploadOperation
	}
	return nil
}

func (m *UploadPlaylistRequest) GetPlaylist() []*Playlist {
	if m != nil {
		return m.Playlist
	}
	return nil
}

func (m *UploadPlaylistRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

type PlaylistResponse struct {
	ResponseStatus   *ResponseStatus `protobuf:"bytes,1,req,name=response_status" json:"response_status,omitempty"`
	ClientId         *string         `protobuf:"bytes,2,opt,name=client_id" json:"client_id,omitempty"`
	ServerId         *string         `protobuf:"bytes,3,opt,name=server_id" json:"server_id,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *PlaylistResponse) Reset()         { *m = PlaylistResponse{} }
func (m *PlaylistResponse) String() string { return proto.CompactTextString(m) }
func (*PlaylistResponse) ProtoMessage()    {}

func (m *PlaylistResponse) GetResponseStatus() *ResponseStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return nil
}

func (m *PlaylistResponse) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *PlaylistResponse) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

type UploadPlaylistResponse struct {
	PlaylistResponse []*PlaylistResponse `protobuf:"bytes,1,rep,name=playlist_response" json:"playlist_response,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *UploadPlaylistResponse) Reset()         { *m = UploadPlaylistResponse{} }
func (m *UploadPlaylistResponse) String() string { return proto.CompactTextString(m) }
func (*UploadPlaylistResponse) ProtoMessage()    {}

func (m *UploadPlaylistResponse) GetPlaylistResponse() []*PlaylistResponse {
	if m != nil {
		return m.PlaylistResponse
	}
	return nil
}

type UploadPlaylistEntryRequest struct {
	UploadOperation  *UploadOperation `protobuf:"bytes,1,req,name=upload_operation" json:"upload_operation,omitempty"`
	PlaylistEntry    []*PlaylistEntry `protobuf:"bytes,2,rep,name=playlist_entry" json:"playlist_entry,omitempty"`
	UploaderId       *string          `protobuf:"bytes,3,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *UploadPlaylistEntryRequest) Reset()         { *m = UploadPlaylistEntryRequest{} }
func (m *UploadPlaylistEntryRequest) String() string { return proto.CompactTextString(m) }
func (*UploadPlaylistEntryRequest) ProtoMessage()    {}

func (m *UploadPlaylistEntryRequest) GetUploadOperation() *UploadOperation {
	if m != nil {
		return m.UploadOperation
	}
	return nil
}

func (m *UploadPlaylistEntryRequest) GetPlaylistEntry() []*PlaylistEntry {
	if m != nil {
		return m.PlaylistEntry
	}
	return nil
}

func (m *UploadPlaylistEntryRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

type PlaylistEntryResponse struct {
	ResponseStatus   *ResponseStatus `protobuf:"bytes,1,req,name=response_status" json:"response_status,omitempty"`
	ClientId         *string         `protobuf:"bytes,2,opt,name=client_id" json:"client_id,omitempty"`
	ServerId         *string         `protobuf:"bytes,3,opt,name=server_id" json:"server_id,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *PlaylistEntryResponse) Reset()         { *m = PlaylistEntryResponse{} }
func (m *PlaylistEntryResponse) String() string { return proto.CompactTextString(m) }
func (*PlaylistEntryResponse) ProtoMessage()    {}

func (m *PlaylistEntryResponse) GetResponseStatus() *ResponseStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return nil
}

func (m *PlaylistEntryResponse) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *PlaylistEntryResponse) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

type UploadPlaylistEntryResponse struct {
	PlaylistEntryResponse []*PlaylistEntryResponse `protobuf:"bytes,1,rep,name=playlist_entry_response" json:"playlist_entry_response,omitempty"`
	XXX_unrecognized      []byte                   `json:"-"`
}

func (m *UploadPlaylistEntryResponse) Reset()         { *m = UploadPlaylistEntryResponse{} }
func (m *UploadPlaylistEntryResponse) String() string { return proto.CompactTextString(m) }
func (*UploadPlaylistEntryResponse) ProtoMessage()    {}

func (m *UploadPlaylistEntryResponse) GetPlaylistEntryResponse() []*PlaylistEntryResponse {
	if m != nil {
		return m.PlaylistEntryResponse
	}
	return nil
}

// Arguments to UploadService.UploadMetadata.
type UploadMetadataRequest struct {
	// The metadata to upload.
	Track []*Track `protobuf:"bytes,1,rep,name=track" json:"track,omitempty"`
	// The device ID.
	UploaderId       *string `protobuf:"bytes,2,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UploadMetadataRequest) Reset()         { *m = UploadMetadataRequest{} }
func (m *UploadMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*UploadMetadataRequest) ProtoMessage()    {}

func (m *UploadMetadataRequest) GetTrack() []*Track {
	if m != nil {
		return m.Track
	}
	return nil
}

func (m *UploadMetadataRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

// Arguments to UploadService.UpdateUploadState.
type UpdateUploadStateRequest struct {
	// The new upload state.
	State *UpdateUploadStateRequest_UploadState `protobuf:"varint,1,req,name=state,enum=musicmanager.UpdateUploadStateRequest_UploadState" json:"state,omitempty"`
	// The device ID.
	UploaderId       *string `protobuf:"bytes,2,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UpdateUploadStateRequest) Reset()         { *m = UpdateUploadStateRequest{} }
func (m *UpdateUploadStateRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateUploadStateRequest) ProtoMessage()    {}

func (m *UpdateUploadStateRequest) GetState() UpdateUploadStateRequest_UploadState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return UpdateUploadStateRequest_START
}

func (m *UpdateUploadStateRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

// Arguments to UploadService.ClientState.
type ClientStateRequest struct {
	// The device ID.
	UploaderId *string `protobuf:"bytes,1,req,name=uploader_id" json:"uploader_id,omitempty"`
	// Undocumented fields.
	GetPurchasedTracksSince *int64 `protobuf:"varint,2,opt,name=get_purchased_tracks_since" json:"get_purchased_tracks_since,omitempty"`
	XXX_unrecognized        []byte `json:"-"`
}

func (m *ClientStateRequest) Reset()         { *m = ClientStateRequest{} }
func (m *ClientStateRequest) String() string { return proto.CompactTextString(m) }
func (*ClientStateRequest) ProtoMessage()    {}

func (m *ClientStateRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

func (m *ClientStateRequest) GetGetPurchasedTracksSince() int64 {
	if m != nil && m.GetPurchasedTracksSince != nil {
		return *m.GetPurchasedTracksSince
	}
	return 0
}

// Return values of UploadService.ClientState.
type ClientStateResponse struct {
	// Maximum number of user-uploaded tracks.
	LockerTrackLimit *int64 `protobuf:"varint,1,opt,name=locker_track_limit" json:"locker_track_limit,omitempty"`
	// Presumably the number of user-uploaded tracks, but this doesn't
	// seem to be accurate.
	UserSongsInLocker *int64 `protobuf:"varint,2,opt,name=user_songs_in_locker" json:"user_songs_in_locker,omitempty"`
	// User-uploaded track size limit in megabytes.
	TrackSizeLimitInMb *int32 `protobuf:"varint,3,opt,name=track_size_limit_in_mb" json:"track_size_limit_in_mb,omitempty"`
	// Unknown.
	UserPurchasedTracksSince *int64 `protobuf:"varint,4,opt,name=user_purchased_tracks_since" json:"user_purchased_tracks_since,omitempty"`
	// Total number of tracks in user's library.
	TotalTrackCount  *int64 `protobuf:"varint,5,opt,name=total_track_count" json:"total_track_count,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ClientStateResponse) Reset()         { *m = ClientStateResponse{} }
func (m *ClientStateResponse) String() string { return proto.CompactTextString(m) }
func (*ClientStateResponse) ProtoMessage()    {}

func (m *ClientStateResponse) GetLockerTrackLimit() int64 {
	if m != nil && m.LockerTrackLimit != nil {
		return *m.LockerTrackLimit
	}
	return 0
}

func (m *ClientStateResponse) GetUserSongsInLocker() int64 {
	if m != nil && m.UserSongsInLocker != nil {
		return *m.UserSongsInLocker
	}
	return 0
}

func (m *ClientStateResponse) GetTrackSizeLimitInMb() int32 {
	if m != nil && m.TrackSizeLimitInMb != nil {
		return *m.TrackSizeLimitInMb
	}
	return 0
}

func (m *ClientStateResponse) GetUserPurchasedTracksSince() int64 {
	if m != nil && m.UserPurchasedTracksSince != nil {
		return *m.UserPurchasedTracksSince
	}
	return 0
}

func (m *ClientStateResponse) GetTotalTrackCount() int64 {
	if m != nil && m.TotalTrackCount != nil {
		return *m.TotalTrackCount
	}
	return 0
}

// Return values of UploadService.UploadMetadata.
type UploadMetadataResponse struct {
	// Requests for track samples.
	SignedChallengeInfo []*SignedChallengeInfo `protobuf:"bytes,1,rep,name=signed_challenge_info" json:"signed_challenge_info,omitempty"`
	// Unknown.
	UploadId []string `protobuf:"bytes,2,rep,name=upload_id" json:"upload_id,omitempty"`
	// Upload requests and rejections.
	TrackSampleResponse []*TrackSampleResponse `protobuf:"bytes,3,rep,name=track_sample_response" json:"track_sample_response,omitempty"`
	XXX_unrecognized    []byte                 `json:"-"`
}

func (m *UploadMetadataResponse) Reset()         { *m = UploadMetadataResponse{} }
func (m *UploadMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*UploadMetadataResponse) ProtoMessage()    {}

func (m *UploadMetadataResponse) GetSignedChallengeInfo() []*SignedChallengeInfo {
	if m != nil {
		return m.SignedChallengeInfo
	}
	return nil
}

func (m *UploadMetadataResponse) GetUploadId() []string {
	if m != nil {
		return m.UploadId
	}
	return nil
}

func (m *UploadMetadataResponse) GetTrackSampleResponse() []*TrackSampleResponse {
	if m != nil {
		return m.TrackSampleResponse
	}
	return nil
}

// A response to a metadata or track sample upload.
type TrackSampleResponse struct {
	// The client ID of the track for which this is a response.
	ClientTrackId *string `protobuf:"bytes,1,req,name=client_track_id" json:"client_track_id,omitempty"`
	// The response code.
	ResponseCode *TrackSampleResponse_ResponseCode `protobuf:"varint,2,req,name=response_code,enum=musicmanager.TrackSampleResponse_ResponseCode" json:"response_code,omitempty"`
	// A possible server ID for the track.
	ServerTrackId *string `protobuf:"bytes,3,opt,name=server_track_id" json:"server_track_id,omitempty"`
	// Undocumented fields.
	AlbumArtUrl      *string `protobuf:"bytes,4,opt,name=album_art_url" json:"album_art_url,omitempty"`
	ExpectMatch      *bool   `protobuf:"varint,5,opt,name=expect_match" json:"expect_match,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TrackSampleResponse) Reset()         { *m = TrackSampleResponse{} }
func (m *TrackSampleResponse) String() string { return proto.CompactTextString(m) }
func (*TrackSampleResponse) ProtoMessage()    {}

func (m *TrackSampleResponse) GetClientTrackId() string {
	if m != nil && m.ClientTrackId != nil {
		return *m.ClientTrackId
	}
	return ""
}

func (m *TrackSampleResponse) GetResponseCode() TrackSampleResponse_ResponseCode {
	if m != nil && m.ResponseCode != nil {
		return *m.ResponseCode
	}
	return TrackSampleResponse_MATCHED
}

func (m *TrackSampleResponse) GetServerTrackId() string {
	if m != nil && m.ServerTrackId != nil {
		return *m.ServerTrackId
	}
	return ""
}

func (m *TrackSampleResponse) GetAlbumArtUrl() string {
	if m != nil && m.AlbumArtUrl != nil {
		return *m.AlbumArtUrl
	}
	return ""
}

func (m *TrackSampleResponse) GetExpectMatch() bool {
	if m != nil && m.ExpectMatch != nil {
		return *m.ExpectMatch
	}
	return false
}

// Arguments to UploadService.UploadSample.
type UploadSampleRequest struct {
	// Track samples to upload.
	TrackSample []*TrackSample `protobuf:"bytes,1,rep,name=track_sample" json:"track_sample,omitempty"`
	// The device ID.
	UploaderId       *string `protobuf:"bytes,2,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UploadSampleRequest) Reset()         { *m = UploadSampleRequest{} }
func (m *UploadSampleRequest) String() string { return proto.CompactTextString(m) }
func (*UploadSampleRequest) ProtoMessage()    {}

func (m *UploadSampleRequest) GetTrackSample() []*TrackSample {
	if m != nil {
		return m.TrackSample
	}
	return nil
}

func (m *UploadSampleRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

// Return values of UploadService.UploadSample.
type UploadSampleResponse struct {
	// Upload requests and rejections, same as in UploadMetadataResponse.
	TrackSampleResponse []*TrackSampleResponse `protobuf:"bytes,1,rep,name=track_sample_response" json:"track_sample_response,omitempty"`
	XXX_unrecognized    []byte                 `json:"-"`
}

func (m *UploadSampleResponse) Reset()         { *m = UploadSampleResponse{} }
func (m *UploadSampleResponse) String() string { return proto.CompactTextString(m) }
func (*UploadSampleResponse) ProtoMessage()    {}

func (m *UploadSampleResponse) GetTrackSampleResponse() []*TrackSampleResponse {
	if m != nil {
		return m.TrackSampleResponse
	}
	return nil
}

type ImageUnion struct {
	UserAlbumArt     []byte  `protobuf:"bytes,1,opt,name=user_album_art" json:"user_album_art,omitempty"`
	AlbumArtUrl      *string `protobuf:"bytes,2,opt,name=album_art_url" json:"album_art_url,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ImageUnion) Reset()         { *m = ImageUnion{} }
func (m *ImageUnion) String() string { return proto.CompactTextString(m) }
func (*ImageUnion) ProtoMessage()    {}

func (m *ImageUnion) GetUserAlbumArt() []byte {
	if m != nil {
		return m.UserAlbumArt
	}
	return nil
}

func (m *ImageUnion) GetAlbumArtUrl() string {
	if m != nil && m.AlbumArtUrl != nil {
		return *m.AlbumArtUrl
	}
	return ""
}

// Return values of all UploadService calls.  The response_type field
// holds the type of the actual response, with its body in one of the
// other fields of the message.  Note that not all responses have a
// body; see the documentation for UploadService for more details.
type UploadResponse struct {
	// Response fields.
	MetadataResponse      *UploadMetadataResponse      `protobuf:"bytes,2,opt,name=metadata_response" json:"metadata_response,omitempty"`
	PlaylistResponse      *UploadPlaylistResponse      `protobuf:"bytes,3,opt,name=playlist_response" json:"playlist_response,omitempty"`
	PlaylistEntryResponse *UploadPlaylistEntryResponse `protobuf:"bytes,4,opt,name=playlist_entry_response" json:"playlist_entry_response,omitempty"`
	SampleResponse        *UploadSampleResponse        `protobuf:"bytes,5,opt,name=sample_response" json:"sample_response,omitempty"`
	GetjobsResponse       *GetJobsResponse             `protobuf:"bytes,7,opt,name=getjobs_response" json:"getjobs_response,omitempty"`
	ClientstateResponse   *ClientStateResponse         `protobuf:"bytes,8,opt,name=clientstate_response" json:"clientstate_response,omitempty"`
	AuthStatus            *UploadResponse_AuthStatus   `protobuf:"varint,11,opt,name=auth_status,enum=musicmanager.UploadResponse_AuthStatus" json:"auth_status,omitempty"`
	// Non-response fields.  response_type tells the type of the
	// response; the others are undocumented.
	ResponseType     *UploadResponse_ResponseType `protobuf:"varint,1,opt,name=response_type,enum=musicmanager.UploadResponse_ResponseType" json:"response_type,omitempty"`
	Policy           *ClientPolicy                `protobuf:"bytes,6,opt,name=policy" json:"policy,omitempty"`
	AuthError        *bool                        `protobuf:"varint,12,opt,name=auth_error" json:"auth_error,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}

func (m *UploadResponse) GetMetadataResponse() *UploadMetadataResponse {
	if m != nil {
		return m.MetadataResponse
	}
	return nil
}

func (m *UploadResponse) GetPlaylistResponse() *UploadPlaylistResponse {
	if m != nil {
		return m.PlaylistResponse
	}
	return nil
}

func (m *UploadResponse) GetPlaylistEntryResponse() *UploadPlaylistEntryResponse {
	if m != nil {
		return m.PlaylistEntryResponse
	}
	return nil
}

func (m *UploadResponse) GetSampleResponse() *UploadSampleResponse {
	if m != nil {
		return m.SampleResponse
	}
	return nil
}

func (m *UploadResponse) GetGetjobsResponse() *GetJobsResponse {
	if m != nil {
		return m.GetjobsResponse
	}
	return nil
}

func (m *UploadResponse) GetClientstateResponse() *ClientStateResponse {
	if m != nil {
		return m.ClientstateResponse
	}
	return nil
}

func (m *UploadResponse) GetAuthStatus() UploadResponse_AuthStatus {
	if m != nil && m.AuthStatus != nil {
		return *m.AuthStatus
	}
	return UploadResponse_OK
}

func (m *UploadResponse) GetResponseType() UploadResponse_ResponseType {
	if m != nil && m.ResponseType != nil {
		return *m.ResponseType
	}
	return UploadResponse_METADATA_RESPONSE
}

func (m *UploadResponse) GetPolicy() *ClientPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *UploadResponse) GetAuthError() bool {
	if m != nil && m.AuthError != nil {
		return *m.AuthError
	}
	return false
}

// An outstanding upload job.
type TracksToUpload struct {
	// The client ID of the track to be uploaded.
	ClientId *string `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	// The server ID of the track to be uploaded.
	ServerId *string `protobuf:"bytes,2,req,name=server_id" json:"server_id,omitempty"`
	// Status of the upload job.
	Status           *TracksToUpload_TrackStatus `protobuf:"varint,5,req,name=status,enum=musicmanager.TracksToUpload_TrackStatus" json:"status,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *TracksToUpload) Reset()         { *m = TracksToUpload{} }
func (m *TracksToUpload) String() string { return proto.CompactTextString(m) }
func (*TracksToUpload) ProtoMessage()    {}

func (m *TracksToUpload) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *TracksToUpload) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

func (m *TracksToUpload) GetStatus() TracksToUpload_TrackStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return TracksToUpload_FORCE_REUPLOAD
}

// Arguments to UploadService.GetJobs.
type GetJobsRequest struct {
	// The device ID.
	UploaderId       *string `protobuf:"bytes,1,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GetJobsRequest) Reset()         { *m = GetJobsRequest{} }
func (m *GetJobsRequest) String() string { return proto.CompactTextString(m) }
func (*GetJobsRequest) ProtoMessage()    {}

func (m *GetJobsRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

// Return values of UploadService.GetJobs.
type GetJobsResponse struct {
	// The upload jobs.
	TracksToUpload []*TracksToUpload `protobuf:"bytes,1,rep,name=tracks_to_upload" json:"tracks_to_upload,omitempty"`
	// True on success, false on failure.
	GetTracksSuccess *bool  `protobuf:"varint,2,req,name=get_tracks_success" json:"get_tracks_success,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *GetJobsResponse) Reset()         { *m = GetJobsResponse{} }
func (m *GetJobsResponse) String() string { return proto.CompactTextString(m) }
func (*GetJobsResponse) ProtoMessage()    {}

func (m *GetJobsResponse) GetTracksToUpload() []*TracksToUpload {
	if m != nil {
		return m.TracksToUpload
	}
	return nil
}

func (m *GetJobsResponse) GetGetTracksSuccess() bool {
	if m != nil && m.GetTracksSuccess != nil {
		return *m.GetTracksSuccess
	}
	return false
}

// Arguments to UploadService.UpAuthRequest.
type UpAuthRequest struct {
	// The device ID to authorize.
	UploaderId *string `protobuf:"bytes,1,req,name=uploader_id" json:"uploader_id,omitempty"`
	// A human-readable name for the device.  This is shown in the
	// device listings given by various Play Music clients.
	FriendlyName     *string `protobuf:"bytes,2,opt,name=friendly_name" json:"friendly_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UpAuthRequest) Reset()         { *m = UpAuthRequest{} }
func (m *UpAuthRequest) String() string { return proto.CompactTextString(m) }
func (*UpAuthRequest) ProtoMessage()    {}

func (m *UpAuthRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

func (m *UpAuthRequest) GetFriendlyName() string {
	if m != nil && m.FriendlyName != nil {
		return *m.FriendlyName
	}
	return ""
}

// Arguments to UploadService.DeleteUploadRequested.
type DeleteUploadRequestedRequest struct {
	// The device ID.
	UploaderId       *string `protobuf:"bytes,1,req,name=uploader_id" json:"uploader_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DeleteUploadRequestedRequest) Reset()         { *m = DeleteUploadRequestedRequest{} }
func (m *DeleteUploadRequestedRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUploadRequestedRequest) ProtoMessage()    {}

func (m *DeleteUploadRequestedRequest) GetUploaderId() string {
	if m != nil && m.UploaderId != nil {
		return *m.UploaderId
	}
	return ""
}

type ClientPolicy struct {
	PauseUploads             *bool   `protobuf:"varint,1,opt,name=pause_uploads" json:"pause_uploads,omitempty"`
	Abort                    *bool   `protobuf:"varint,2,opt,name=abort" json:"abort,omitempty"`
	RetryInMinutes           *int32  `protobuf:"varint,3,opt,name=retry_in_minutes" json:"retry_in_minutes,omitempty"`
	BandwidthCapKbps         *int32  `protobuf:"varint,4,opt,name=bandwidth_cap_kbps" json:"bandwidth_cap_kbps,omitempty"`
	PauseDownloads           *bool   `protobuf:"varint,5,opt,name=pause_downloads" json:"pause_downloads,omitempty"`
	DownloadBandwidthCapKbps *int32  `protobuf:"varint,6,opt,name=download_bandwidth_cap_kbps" json:"download_bandwidth_cap_kbps,omitempty"`
	SendAnalytics            *bool   `protobuf:"varint,7,opt,name=send_analytics" json:"send_analytics,omitempty"`
	AnalyticsUrl             *string `protobuf:"bytes,8,opt,name=analytics_url" json:"analytics_url,omitempty"`
	EnableGapless            *bool   `protobuf:"varint,9,opt,name=enable_gapless" json:"enable_gapless,omitempty"`
	EnableM4P                *bool   `protobuf:"varint,10,opt,name=enable_m4p" json:"enable_m4p,omitempty"`
	XXX_unrecognized         []byte  `json:"-"`
}

func (m *ClientPolicy) Reset()         { *m = ClientPolicy{} }
func (m *ClientPolicy) String() string { return proto.CompactTextString(m) }
func (*ClientPolicy) ProtoMessage()    {}

func (m *ClientPolicy) GetPauseUploads() bool {
	if m != nil && m.PauseUploads != nil {
		return *m.PauseUploads
	}
	return false
}

func (m *ClientPolicy) GetAbort() bool {
	if m != nil && m.Abort != nil {
		return *m.Abort
	}
	return false
}

func (m *ClientPolicy) GetRetryInMinutes() int32 {
	if m != nil && m.RetryInMinutes != nil {
		return *m.RetryInMinutes
	}
	return 0
}

func (m *ClientPolicy) GetBandwidthCapKbps() int32 {
	if m != nil && m.BandwidthCapKbps != nil {
		return *m.BandwidthCapKbps
	}
	return 0
}

func (m *ClientPolicy) GetPauseDownloads() bool {
	if m != nil && m.PauseDownloads != nil {
		return *m.PauseDownloads
	}
	return false
}

func (m *ClientPolicy) GetDownloadBandwidthCapKbps() int32 {
	if m != nil && m.DownloadBandwidthCapKbps != nil {
		return *m.DownloadBandwidthCapKbps
	}
	return 0
}

func (m *ClientPolicy) GetSendAnalytics() bool {
	if m != nil && m.SendAnalytics != nil {
		return *m.SendAnalytics
	}
	return false
}

func (m *ClientPolicy) GetAnalyticsUrl() string {
	if m != nil && m.AnalyticsUrl != nil {
		return *m.AnalyticsUrl
	}
	return ""
}

func (m *ClientPolicy) GetEnableGapless() bool {
	if m != nil && m.EnableGapless != nil {
		return *m.EnableGapless
	}
	return false
}

func (m *ClientPolicy) GetEnableM4P() bool {
	if m != nil && m.EnableM4P != nil {
		return *m.EnableM4P
	}
	return false
}

type UploadMetadataInternalRequest struct {
	Gaiaid           *uint64                `protobuf:"varint,1,req,name=gaiaid" json:"gaiaid,omitempty"`
	Request          *UploadMetadataRequest `protobuf:"bytes,2,req,name=request" json:"request,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *UploadMetadataInternalRequest) Reset()         { *m = UploadMetadataInternalRequest{} }
func (m *UploadMetadataInternalRequest) String() string { return proto.CompactTextString(m) }
func (*UploadMetadataInternalRequest) ProtoMessage()    {}

func (m *UploadMetadataInternalRequest) GetGaiaid() uint64 {
	if m != nil && m.Gaiaid != nil {
		return *m.Gaiaid
	}
	return 0
}

func (m *UploadMetadataInternalRequest) GetRequest() *UploadMetadataRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type OverrideConfigValue struct {
	Key              *string                               `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            *string                               `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Priority         *OverrideConfigValue_OverridePriority `protobuf:"varint,3,opt,name=priority,enum=musicmanager.OverrideConfigValue_OverridePriority" json:"priority,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *OverrideConfigValue) Reset()         { *m = OverrideConfigValue{} }
func (m *OverrideConfigValue) String() string { return proto.CompactTextString(m) }
func (*OverrideConfigValue) ProtoMessage()    {}

func (m *OverrideConfigValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *OverrideConfigValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *OverrideConfigValue) GetPriority() OverrideConfigValue_OverridePriority {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return OverrideConfigValue_DEFAULT_PRIORITY
}

type OverrideConfigValueCollection struct {
	Value            []*OverrideConfigValue `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *OverrideConfigValueCollection) Reset()         { *m = OverrideConfigValueCollection{} }
func (m *OverrideConfigValueCollection) String() string { return proto.CompactTextString(m) }
func (*OverrideConfigValueCollection) ProtoMessage()    {}

func (m *OverrideConfigValueCollection) GetValue() []*OverrideConfigValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterEnum("musicmanager.ResponseStatus_ResponseCode", ResponseStatus_ResponseCode_name, ResponseStatus_ResponseCode_value)
	proto.RegisterEnum("musicmanager.UploadOperation_Operation", UploadOperation_Operation_name, UploadOperation_Operation_value)
	proto.RegisterEnum("musicmanager.UpdateUploadStateRequest_UploadState", UpdateUploadStateRequest_UploadState_name, UpdateUploadStateRequest_UploadState_value)
	proto.RegisterEnum("musicmanager.TrackSampleResponse_ResponseCode", TrackSampleResponse_ResponseCode_name, TrackSampleResponse_ResponseCode_value)
	proto.RegisterEnum("musicmanager.UploadResponse_ResponseType", UploadResponse_ResponseType_name, UploadResponse_ResponseType_value)
	proto.RegisterEnum("musicmanager.UploadResponse_AuthStatus", UploadResponse_AuthStatus_name, UploadResponse_AuthStatus_value)
	proto.RegisterEnum("musicmanager.TracksToUpload_TrackStatus", TracksToUpload_TrackStatus_name, TracksToUpload_TrackStatus_value)
	proto.RegisterEnum("musicmanager.OverrideConfigValue_OverridePriority", OverrideConfigValue_OverridePriority_name, OverrideConfigValue_OverridePriority_value)
}
